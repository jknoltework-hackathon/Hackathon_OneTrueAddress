<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cool & Gang Communications - Address Matching</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <!-- Settings Button -->
    <button class="settings-btn" id="settingsBtn" aria-label="Settings">
        ‚ò∞
    </button>

    <!-- Time Saved Widget -->
    <div class="time-saved-widget" id="timeSavedWidget">
        <div class="time-saved-icon">‚è±Ô∏è</div>
        <div class="time-saved-content">
            <div class="time-saved-label">Time Saved</div>
            <div class="time-saved-value" id="timeSavedValue">
                <span class="hours-value">--</span> hours
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div class="settings-menu" id="settingsMenu">
        <div class="settings-menu-header">
            <h3>Settings</h3>
            <button class="close-settings-btn" id="closeSettingsBtn" aria-label="Close settings">√ó</button>
        </div>
        <div class="settings-menu-body">
            <div class="settings-section">
                <h4>Theme</h4>
                <div class="theme-options">
                    <label class="theme-option">
                        <input type="radio" name="theme" value="light" checked>
                        <span class="theme-option-label">
                            <span class="theme-icon">‚òÄÔ∏è</span>
                            <div>
                                <div class="theme-icon-text">Light</div>
                                <div class="theme-name">Bright and colorful</div>
                            </div>
                        </span>
                    </label>
                    <label class="theme-option">
                        <input type="radio" name="theme" value="dark">
                        <span class="theme-option-label">
                            <span class="theme-icon">üåô</span>
                            <div>
                                <div class="theme-icon-text">Dark</div>
                                <div class="theme-name">Easy on the eyes</div>
                            </div>
                        </span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <div class="logo-container">
                <img src="{{ url_for('static', filename='logo.png') }}" alt="Cool & Gang Communications Logo" class="company-logo" onerror="this.style.display='none'">
            </div>
            <h1 class="company-name"></h1>
            <p class="subtitle"></p>
        </header>
        <main>
            <div class="two-column-layout">
                <!-- Left Column: Input and System Response -->
                <div class="left-column">
                    <div class="input-section">
                        <form id="addressForm">
                            <div class="form-group">
                                <label for="addressInput">Enter Address to Match:</label>
                                <textarea 
                                    id="addressInput" 
                                    name="address" 
                                    rows="4" 
                                    placeholder="Enter a free-form address (e.g., 123 Main St, New York, NY 10001)"
                                    required
                                ></textarea>
                            </div>
                            
                            <div class="form-group slider-group">
                                <label for="thresholdSlider">
                                    Fuzzy Match Threshold: <span id="thresholdValue">90</span>%
                                </label>
                                <input 
                                    type="range" 
                                    id="thresholdSlider" 
                                    name="threshold" 
                                    min="75" 
                                    max="100" 
                                    value="90" 
                                    step="1"
                                    class="threshold-slider"
                                >
                                <div class="slider-labels">
                                    <span>75% (More Matches)</span>
                                    <span>100% (Exact Matches)</span>
                                </div>
                            </div>
                            
                            <button type="submit" id="submitBtn" class="submit-btn">
                                <span class="btn-text">Search For Your Address</span>
                                <span class="btn-loader" style="display: none;">Processing...</span>
                            </button>
                            <button type="button" id="doOverBtn" class="do-over-btn" style="display: none;">
                                Do Over
                            </button>
                        </form>
                    </div>

                    <div id="systemResponse" class="system-response-section" style="display: none;">
                        <h2>System Response</h2>
                        <div id="systemResponseContent"></div>
                    </div>

                    <div id="error" class="error-section" style="display: none;">
                        <h3>Error</h3>
                        <p id="errorMessage"></p>
                    </div>
                </div>

                <!-- Right Column: Matched Addresses -->
                <div class="right-column">
                    <div class="matched-addresses-header">
                        <h2>Matched Addresses</h2>
                        <div id="matchCount" class="match-count" style="display: none;"></div>
                    </div>
                    <div id="matchedAddresses" class="matched-addresses-container">
                        <div class="empty-state">
                            <p>Enter an address to see matched results here.</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const form = document.getElementById('addressForm');
        const submitBtn = document.getElementById('submitBtn');
        const btnText = submitBtn.querySelector('.btn-text');
        const btnLoader = submitBtn.querySelector('.btn-loader');
        const doOverBtn = document.getElementById('doOverBtn');
        const systemResponseSection = document.getElementById('systemResponse');
        const systemResponseContent = document.getElementById('systemResponseContent');
        const matchedAddressesContainer = document.getElementById('matchedAddresses');
        const matchCount = document.getElementById('matchCount');
        const errorSection = document.getElementById('error');
        const errorMessage = document.getElementById('errorMessage');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');

        // Update threshold value display when slider changes
        thresholdSlider.addEventListener('input', (e) => {
            thresholdValue.textContent = e.target.value;
        });

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const addressInput = document.getElementById('addressInput');
            const address = addressInput.value.trim();
            const threshold = parseFloat(thresholdSlider.value);
            
            if (!address) {
                showError('Please enter an address to match.');
                return;
            }

            // Hide previous results/errors
            systemResponseSection.style.display = 'none';
            errorSection.style.display = 'none';
            matchedAddressesContainer.innerHTML = '<div class="empty-state"><p>Processing...</p></div>';
            
            // Show loading state
            submitBtn.disabled = true;
            btnText.style.display = 'none';
            btnLoader.style.display = 'inline';

            try {
                const response = await fetch('/match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        address: address,
                        threshold: threshold
                    })
                });

                const data = await response.json();
                
                // Debug logging for match response
                console.log('Match Response Data:');
                console.log('  Match found:', data.match_found);
                console.log('  Matched address:', data.matched_address);
                console.log('  Internal matches:', data.internal_matches);

                if (data.success) {
                    displayResults(data);
                    doOverBtn.style.display = 'inline-block';
                } else {
                    showError(data.error || 'An error occurred while matching the address.');
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            } finally {
                // Reset button state
                submitBtn.disabled = false;
                btnText.style.display = 'inline';
                btnLoader.style.display = 'none';
            }
        });

        doOverBtn.addEventListener('click', () => {
            // Clear the form
            form.reset();
            
            // Hide all results and errors
            systemResponseSection.style.display = 'none';
            errorSection.style.display = 'none';
            matchCount.style.display = 'none';
            doOverBtn.style.display = 'none';
            
            // Reset matched addresses container to empty state
            matchedAddressesContainer.innerHTML = '<div class="empty-state"><p>Enter an address to see matched results here.</p></div>';
            
            // Focus on the address input
            document.getElementById('addressInput').focus();
        });

        function displayResults(data) {
            // Left Column: System Response (Input, Status, Confidence, Reasoning)
            let systemHtml = '';

            systemHtml += `<div class="response-item">
                <strong>Input Address:</strong> ${escapeHtml(data.input_address)}
            </div>`;

            systemHtml += `<div class="response-item">
                <strong>Candidates Searched:</strong> ${data.candidates_searched}
            </div>`;

            if (data.match_found) {
                systemHtml += `<div class="response-item match-found">
                    <strong>Status:</strong> <span class="status-badge success">‚úì Match Found</span>
                </div>`;

                systemHtml += `<div class="response-item">
                    <strong>Confidence:</strong> <span class="confidence ${getConfidenceClass(data.confidence)}">${data.confidence}%</span>
                </div>`;

                if (data.business_rule_exception) {
                    systemHtml += `<div class="response-item warning">
                        <strong>‚ö†Ô∏è Business Rule Exception:</strong> Confidence (${data.confidence}%) is below threshold (${data.confidence_threshold}%). This match requires manual review.
                    </div>`;
                }
            } else {
                systemHtml += `<div class="response-item match-not-found">
                    <strong>Status:</strong> <span class="status-badge error">‚úó No Match Found</span>
                </div>`;

                if (data.confidence !== 'N/A') {
                    systemHtml += `<div class="response-item">
                        <strong>Confidence:</strong> <span class="confidence">${data.confidence}%</span>
                    </div>`;
                }
            }

            if (data.reasoning) {
                systemHtml += `<div class="response-item reasoning">
                    <strong>Reasoning:</strong> ${escapeHtml(data.reasoning)}
                </div>`;
            }

            systemResponseContent.innerHTML = systemHtml;
            systemResponseSection.style.display = 'block';

            // Right Column: Matched Addresses
            let addressesHtml = '';
            
            console.log('Match found:', data.match_found);
            console.log('Matched address:', data.matched_address);
            console.log('Golden source matches:', data.golden_source_matches);
            console.log('Internal matches:', data.internal_matches);
            
            if (data.match_found) {
                // Display "Exact Match Found" message only if single internal match AND MasterAddress matches Golden Source
                if (data.internal_matches && data.internal_matches.length === 1 && 
                    data.golden_source_matches && data.golden_source_matches.length > 0) {
                    
                    const goldenMasterAddress = data.golden_source_matches[0].MasterAddress;
                    const internalMasterAddress = data.internal_matches[0].MasterAddress;
                    
                    console.log('Checking for exact match:');
                    console.log('  Golden Source MasterAddress:', goldenMasterAddress);
                    console.log('  Internal MasterAddress:', internalMasterAddress);
                    
                    if (goldenMasterAddress && internalMasterAddress && 
                        goldenMasterAddress.trim() === internalMasterAddress.trim()) {
                        console.log('  ‚úì Exact match confirmed - MasterAddresses are identical');
                        addressesHtml += `
                        <div class="exact-match-message">
                            <div class="exact-match-icon">‚úì</div>
                            <div class="exact-match-text">
                                <h3>Exact Match Found</h3>
                                <p>MasterAddress in Golden Source exactly matches the Internal record. No updates needed.</p>
                            </div>
                        </div>`;
                    } else {
                        console.log('  ‚úó Not an exact match - MasterAddresses differ');
                    }
                }
                
                // Display Golden Source matches section
                console.log('Checking Golden Source section - has_golden_source:', data.has_golden_source);
                if (data.has_golden_source !== false) {
                    if (data.golden_source_matches && data.golden_source_matches.length > 0) {
                        const headerText = 'Golden Source Matches';
                        addressesHtml += `<div class="golden-source-section">
                            <h3 class="golden-source-header">${headerText} (${data.golden_source_matches.length})</h3>`;
                    
                    // Define the specific column order for Golden Source table (exact column names from database)
                    const goldenSourceColumnOrder = [
                        'address1', 'address2', 'Mailing City', 'state', 'zipcode', 
                        'MasterAddress', 'last_edited_date'
                    ];
                    
                    // Field label mapping for prettier display
                    const goldenSourceLabelMap = {
                        'address1': 'Address1',
                        'address2': 'Address2',
                        'Mailing City': 'City',
                        'state': 'State',
                        'zipcode': 'Zipcode',
                        'last_edited_date': 'Last Edited Date'
                    };
                    
                    data.golden_source_matches.forEach((addr, index) => {
                        const score = addr._similarity_score || 0;
                        const aiConfidence = addr._ai_analysis ? (addr._ai_analysis.confidence || 0) : 0;
                        console.log(`Golden Source match ${index + 1}: score=${score.toFixed(1)}%, has AI analysis=${!!addr._ai_analysis}`);
                        if (addr._ai_analysis) {
                            console.log(`  AI analysis:`, addr._ai_analysis);
                        }
                        
                        addressesHtml += `<div class="matched-address-card golden-source">
                            <div class="address-card-header">
                                <span class="address-number">${index + 1}</span>
                                <div class="match-scores">
                                    <span class="fuzzy-match-badge">Fuzzy Match: ${Math.round(score)}%</span>
                                    ${aiConfidence > 0 ? `<span class="ai-match-badge">AI Analysis: ${aiConfidence}%</span>` : ''}
                                </div>
                            </div>`;
                        
                        // Display AI analysis if available
                        if (addr._ai_analysis) {
                            const aiConfidence = addr._ai_analysis.confidence || 0;
                            const aiAssessment = addr._ai_analysis.assessment || 'No analysis available';
                            addressesHtml += `
                            <div class="match-ai-analysis">
                                <div class="ai-analysis-header">
                                    <span class="ai-mini-badge">ü§ñ AI Analysis</span>
                                    <span class="ai-confidence-mini">${aiConfidence}% (beep... boop...)</span>
                                </div>
                                <div class="ai-analysis-text">${escapeHtml(aiAssessment)}</div>
                            </div>`;
                        }
                        
                        addressesHtml += `<div class="address-card-body">`;
                        
                        // Display only the specified fields in the specified order
                        goldenSourceColumnOrder.forEach(key => {
                            if (key in addr) {
                                const displayLabel = goldenSourceLabelMap[key] || key;
                                addressesHtml += `<div class="address-detail">
                                    <span class="address-label">${escapeHtml(displayLabel)}:</span>
                                    <span class="address-value">${escapeHtml(addr[key] || 'N/A')}</span>
                                </div>`;
                            }
                        });
                        
                        addressesHtml += `</div></div>`;
                    });
                    
                        addressesHtml += `</div>`;
                    } else if (data.has_golden_source === false) {
                        // No Golden Source matches found
                        addressesHtml += `<div class="golden-source-section">
                            <h3 class="golden-source-header">Golden Source Matches (0)</h3>
                            <div class="no-matches-message">
                                <p>‚ö†Ô∏è No matches found in Golden Source table for this address.</p>
                            </div>
                        </div>`;
                    }
                }
                
                // Display Internal matches section
                if (data.internal_matches && data.internal_matches.length > 0) {
                    const headerText = 'Internal Matches';
                    addressesHtml += `<div class="internal-section">
                        <h3 class="internal-header">${headerText} (${data.internal_matches.length})</h3>`;
                    
                    // Define the specific column order for Internal table
                    const internalColumnOrder = [
                        'Address', 'City', 'State', 'Zipcode', 'MasterAddress',
                        'Bad Type', 'Active Customer', 'Engineering Review', 
                        'Exclusion', 'ID', 'Media'
                    ];
                    
                    // Sort internal matches by confidence score (highest first)
                    const sortedInternalMatches = [...data.internal_matches].sort((a, b) => {
                        const scoreA = a._similarity_score || 0;
                        const scoreB = b._similarity_score || 0;
                        return scoreB - scoreA; // Descending order
                    });
                    
                    sortedInternalMatches.forEach((addr, index) => {
                        const score = addr._similarity_score || 0;
                        const aiConfidence = addr._ai_analysis ? (addr._ai_analysis.confidence || 0) : 0;
                        console.log(`Internal match ${index + 1}: score=${score.toFixed(1)}%, has AI analysis=${!!addr._ai_analysis}`);
                        if (addr._ai_analysis) {
                            console.log(`  AI analysis:`, addr._ai_analysis);
                        }
                        
                        addressesHtml += `<div class="matched-address-card internal-match">
                            <div class="address-card-header">
                                <span class="address-number">${index + 1}</span>
                                <div class="match-scores">
                                    <span class="fuzzy-match-badge">Fuzzy Match: ${Math.round(score)}%</span>
                                    ${aiConfidence > 0 ? `<span class="ai-match-badge">AI Analysis: ${aiConfidence}%</span>` : ''}
                                </div>
                            </div>`;
                        
                        // Display AI analysis if available
                        if (addr._ai_analysis) {
                            const aiConfidence = addr._ai_analysis.confidence || 0;
                            const aiAssessment = addr._ai_analysis.assessment || 'No analysis available';
                            addressesHtml += `
                            <div class="match-ai-analysis">
                                <div class="ai-analysis-header">
                                    <span class="ai-mini-badge">ü§ñ AI Analysis</span>
                                    <span class="ai-confidence-mini">${aiConfidence}% (beep... boop...)</span>
                                </div>
                                <div class="ai-analysis-text">${escapeHtml(aiAssessment)}</div>
                            </div>`;
                        }
                        
                        addressesHtml += `<div class="address-card-body">`;
                        
                        // Display only the specified fields in the specified order
                        internalColumnOrder.forEach(fieldName => {
                            if (fieldName in addr) {
                                addressesHtml += `<div class="address-detail">
                                    <span class="address-label">${escapeHtml(fieldName)}:</span>
                                    <span class="address-value">${escapeHtml(addr[fieldName] || 'N/A')}</span>
                                </div>`;
                            }
                        });
                        
                        addressesHtml += `</div></div>`;
                    });
                    
                        addressesHtml += `</div>`;
                        
                        // Check if we need to show Push Updates button
                        let needsPushUpdates = false;
                        let pushUpdatesMessage = '';
                        
                        if (data.internal_matches.length > 1) {
                            // Multiple internal matches need consolidation
                            needsPushUpdates = true;
                            pushUpdatesMessage = 'Multiple address records found. Click to consolidate and update the internal database.';
                        } else if (data.internal_matches.length === 1 && 
                                   data.golden_source_matches && data.golden_source_matches.length > 0) {
                            // Single internal match - check if MasterAddress matches
                            const goldenMasterAddress = data.golden_source_matches[0].MasterAddress;
                            const internalMasterAddress = data.internal_matches[0].MasterAddress;
                            
                            if (goldenMasterAddress && internalMasterAddress && 
                                goldenMasterAddress.trim() !== internalMasterAddress.trim()) {
                                // MasterAddresses don't match - need to update
                                needsPushUpdates = true;
                                pushUpdatesMessage = 'MasterAddress differs from Golden Source. Click to update the internal record with the correct Golden Source address.';
                            }
                        }
                        
                        if (needsPushUpdates) {
                            addressesHtml += `
                        <div class="push-updates-section">
                            <button id="pushUpdatesBtn" class="push-updates-btn">
                                <span class="btn-text">Push Updates to Internal Database</span>
                                <span class="btn-loader" style="display: none;">Processing...</span>
                            </button>
                            <p class="push-updates-info">
                                ${pushUpdatesMessage}
                            </p>
                        </div>`;
                        }
                } else if (data.has_internal === false) {
                    // No Internal matches found
                    console.log('No Internal matches - has_internal:', data.has_internal, 'has_golden_source:', data.has_golden_source);
                    addressesHtml += `<div class="internal-section">
                        <h3 class="internal-header">Internal Matches (0)</h3>
                        <div class="no-matches-message">
                            <p>‚ÑπÔ∏è No matches found in Internal table for this address.</p>
                            <p>The address exists in Golden Source but not in the Internal system.</p>
                        </div>
                    </div>`;
                    
                    // Show "Write to Internal" button if Golden Source exists but Internal doesn't
                    if (data.has_golden_source) {
                        console.log('Adding Write to Internal button');
                        addressesHtml += `
                    <div class="push-updates-section">
                        <button id="writeToInternalBtn" class="push-updates-btn">
                            <span class="btn-text">Write to Internal Updates Table</span>
                            <span class="btn-loader" style="display: none;">Processing...</span>
                        </button>
                        <p class="push-updates-info">
                            Click to add this Golden Source address to team_cool_and_gang.internal_updates table.
                        </p>
                    </div>`;
                    } else {
                        console.log('NOT adding Write to Internal button - has_golden_source is false or missing');
                    }
                }
                
                const goldenCount = data.total_golden_source || 0;
                const internalCount = data.total_internal || 0;
                const totalMatches = goldenCount + internalCount;
                matchCount.textContent = `${totalMatches} match${totalMatches !== 1 ? 'es' : ''} found (${goldenCount} Golden Source, ${internalCount} Internal)`;
                matchCount.style.display = 'block';
            } else {
                addressesHtml = '<div class="empty-state"><p>No matches found.</p></div>';
                matchCount.style.display = 'none';
            }

            matchedAddressesContainer.innerHTML = addressesHtml;
            
            // Attach event listener to the "Push Updates" button if it exists
            const pushUpdatesBtn = document.getElementById('pushUpdatesBtn');
            if (pushUpdatesBtn && data.internal_matches) {
                // Validate that matched_address has actual content
                const hasValidAddress = data.matched_address && 
                    Object.keys(data.matched_address).length > 0 &&
                    (data.matched_address.address1 || data.matched_address.state);
                
                if (hasValidAddress) {
                    pushUpdatesBtn.addEventListener('click', async () => {
                        // Determine scenario for Agent Action and TPI
                        let scenario = 1; // Default: Multiple matches
                        if (data.internal_matches.length === 1) {
                            scenario = 2; // Single match with MasterAddress mismatch
                        }
                        await handlePushUpdates(data.internal_matches, data.matched_address, scenario);
                    });
                } else {
                    // Disable button and show error if no valid golden source address
                    pushUpdatesBtn.disabled = true;
                    pushUpdatesBtn.title = "No valid Golden Source address available";
                    console.error("Cannot push updates: Golden Source address is missing or invalid", data.matched_address);
                }
            }
            
            // Attach event listener to the "Write to Internal" button if it exists
            const writeToInternalBtn = document.getElementById('writeToInternalBtn');
            if (writeToInternalBtn) {
                // Use the first Golden Source match as the record to write
                const goldenSourceRecord = data.golden_source_matches && data.golden_source_matches.length > 0 
                    ? data.golden_source_matches[0] 
                    : data.matched_address;
                
                if (goldenSourceRecord) {
                    writeToInternalBtn.addEventListener('click', async () => {
                        await handleWriteToInternal(goldenSourceRecord);
                    });
                } else {
                    writeToInternalBtn.disabled = true;
                    writeToInternalBtn.title = "No Golden Source record available";
                    console.error("Cannot write to internal: No Golden Source record available");
                }
            }
        }
        
        async function handlePushUpdates(internal_matches, golden_source_address, scenario) {
            const pushUpdatesBtn = document.getElementById('pushUpdatesBtn');
            const btnText = pushUpdatesBtn.querySelector('.btn-text');
            const btnLoader = pushUpdatesBtn.querySelector('.btn-loader');
            
            // Debug logging
            console.log('Push Updates - Data being sent:');
            console.log('  Internal Matches:', internal_matches);
            console.log('  Golden Source Address:', golden_source_address);
            console.log('  Scenario:', scenario);
            
            // Show loading state
            pushUpdatesBtn.disabled = true;
            btnText.style.display = 'none';
            btnLoader.style.display = 'inline';
            
            try {
                const requestData = { 
                    internal_matches: internal_matches,
                    golden_source_address: golden_source_address,
                    scenario: scenario
                };
                
                console.log('Request payload:', JSON.stringify(requestData, null, 2));
                
                const response = await fetch('/push_updates', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message
                    alert(`Success! ${data.message}\n\nConsolidated record has been pushed to the internal database.`);
                    
                    // Log the consolidated record
                    console.log('Consolidated Record:', data.consolidated_record);
                    
                    // Update button to show success
                    btnText.textContent = 'Updates Pushed Successfully ‚úì';
                    btnText.style.display = 'inline';
                    btnLoader.style.display = 'none';
                    pushUpdatesBtn.classList.add('success');
                    
                    // Refresh time saved widget
                    fetchTimeSaved();
                    
                    // Display the consolidated record in the UI
                    displayConsolidatedRecord(data.consolidated_record);
                } else {
                    // Show error message
                    if (data.requires_manual_review) {
                        alert(`Manual Review Required\n\n${data.error}\n\nPlease review and update the records manually.`);
                    } else {
                        alert(`Error: ${data.error}`);
                    }
                    
                    // Reset button state
                    pushUpdatesBtn.disabled = false;
                    btnText.style.display = 'inline';
                    btnLoader.style.display = 'none';
                }
            } catch (error) {
                alert('Network error: ' + error.message);
                
                // Reset button state
                pushUpdatesBtn.disabled = false;
                btnText.style.display = 'inline';
                btnLoader.style.display = 'none';
            }
        }
        
        async function handleWriteToInternal(golden_source_record) {
            const writeToInternalBtn = document.getElementById('writeToInternalBtn');
            const btnText = writeToInternalBtn.querySelector('.btn-text');
            const btnLoader = writeToInternalBtn.querySelector('.btn-loader');
            
            // Show loading state
            writeToInternalBtn.disabled = true;
            btnText.style.display = 'none';
            btnLoader.style.display = 'inline';
            
            try {
                const response = await fetch('/write_to_internal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ golden_source_record: golden_source_record })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message
                    alert(`Success! ${data.message}\n\nGolden Source address has been written to team_cool_and_gang.internal_updates.`);
                    
                    // Log the written record
                    console.log('Written Record:', data.written_record);
                    
                    // Update button to show success
                    btnText.textContent = 'Record Written Successfully ‚úì';
                    btnText.style.display = 'inline';
                    btnLoader.style.display = 'none';
                    writeToInternalBtn.classList.add('success');
                    
                    // Refresh time saved widget
                    fetchTimeSaved();
                    
                    // Display the written record in the UI
                    displayWrittenRecord(data.written_record);
                } else {
                    // Show error message
                    alert(`Error: ${data.error}`);
                    
                    // Reset button state
                    writeToInternalBtn.disabled = false;
                    btnText.style.display = 'inline';
                    btnLoader.style.display = 'none';
                }
            } catch (error) {
                alert('Network error: ' + error.message);
                
                // Reset button state
                writeToInternalBtn.disabled = false;
                btnText.style.display = 'inline';
                btnLoader.style.display = 'none';
            }
        }
        
        function displayConsolidatedRecord(consolidatedRecord) {
            // Create a new section to display the consolidated record
            const pushUpdatesSection = document.querySelector('.push-updates-section');
            
            // Check if consolidated record display already exists
            let consolidatedDisplay = document.getElementById('consolidatedRecordDisplay');
            if (!consolidatedDisplay) {
                consolidatedDisplay = document.createElement('div');
                consolidatedDisplay.id = 'consolidatedRecordDisplay';
                consolidatedDisplay.className = 'consolidated-record-display';
                pushUpdatesSection.appendChild(consolidatedDisplay);
            }
            
            // Build the HTML for the consolidated record
            let recordHtml = `
                <div class="consolidated-record-header">
                    <h4>‚úì Consolidated Record Pushed to Internal Database</h4>
                </div>
                <div class="consolidated-record-body">`;
            
            for (const [key, value] of Object.entries(consolidatedRecord)) {
                recordHtml += `
                    <div class="consolidated-detail">
                        <span class="consolidated-label">${escapeHtml(key)}:</span>
                        <span class="consolidated-value">${escapeHtml(value || 'N/A')}</span>
                    </div>`;
            }
            
            recordHtml += `</div>`;
            consolidatedDisplay.innerHTML = recordHtml;
            
            // Scroll to the consolidated record display
            consolidatedDisplay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function displayWrittenRecord(writtenRecord) {
            // Create a new section to display the written record
            const pushUpdatesSection = document.querySelector('.push-updates-section');
            
            // Check if written record display already exists
            let writtenDisplay = document.getElementById('writtenRecordDisplay');
            if (!writtenDisplay) {
                writtenDisplay = document.createElement('div');
                writtenDisplay.id = 'writtenRecordDisplay';
                writtenDisplay.className = 'consolidated-record-display';
                pushUpdatesSection.appendChild(writtenDisplay);
            }
            
            // Build the HTML for the written record
            let recordHtml = `
                <div class="consolidated-record-header">
                    <h4>‚úì Golden Source Record Written to Internal Updates</h4>
                </div>
                <div class="consolidated-record-body">`;
            
            for (const [key, value] of Object.entries(writtenRecord)) {
                recordHtml += `
                    <div class="consolidated-detail">
                        <span class="consolidated-label">${escapeHtml(key)}:</span>
                        <span class="consolidated-value">${escapeHtml(value || 'N/A')}</span>
                    </div>`;
            }
            
            recordHtml += `</div>`;
            writtenDisplay.innerHTML = recordHtml;
            
            // Scroll to the written record display
            writtenDisplay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorSection.style.display = 'block';
            errorSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getConfidenceClass(confidence) {
            if (confidence >= 90) return 'high';
            if (confidence >= 70) return 'medium';
            if (confidence >= 50) return 'low';
            return 'very-low';
        }

        // ============================================================================
        // TIME SAVED WIDGET
        // ============================================================================
        
        async function fetchTimeSaved() {
            try {
                const response = await fetch('/time_saved');
                const data = await response.json();
                
                if (data.success) {
                    const hoursValue = document.querySelector('.hours-value');
                    hoursValue.textContent = data.hours_saved.toFixed(1);
                } else {
                    console.error('Error fetching time saved:', data.error);
                }
            } catch (error) {
                console.error('Network error fetching time saved:', error);
            }
        }
        
        // Fetch time saved on page load
        fetchTimeSaved();
        
        // Refresh time saved every 30 seconds
        setInterval(fetchTimeSaved, 30000);

        // ============================================================================
        // THEME TOGGLE FUNCTIONALITY
        // ============================================================================
        
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsMenu = document.getElementById('settingsMenu');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const themeRadios = document.querySelectorAll('input[name="theme"]');

        // Load saved theme from localStorage
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.body.setAttribute('data-theme', savedTheme);
        
        // Set the correct radio button as checked
        themeRadios.forEach(radio => {
            if (radio.value === savedTheme) {
                radio.checked = true;
            }
        });

        // Open settings menu
        settingsBtn.addEventListener('click', () => {
            settingsMenu.classList.add('show');
        });

        // Close settings menu
        closeSettingsBtn.addEventListener('click', () => {
            settingsMenu.classList.remove('show');
        });

        // Close settings menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsMenu.classList.remove('show');
            }
        });

        // Handle theme changes
        themeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                const selectedTheme = e.target.value;
                document.body.setAttribute('data-theme', selectedTheme);
                localStorage.setItem('theme', selectedTheme);
                // Automatically close the settings menu after theme selection
                settingsMenu.classList.remove('show');
            });
        });
    </script>
</body>
</html>

